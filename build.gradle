import org.apache.tools.ant.taskdefs.condition.Os
import org.apache.commons.io.FileUtils

ext {
    ext {
        phantomJsVersion = '1.9.7'
    }
}

buildscript {
    repositories {
        jcenter()
        maven { url 'http://clojars.org/repo' }
    }
    dependencies {
        classpath "io.ratpack:ratpack-gradle:0.9.16"
        classpath "com.github.jengelman.gradle.plugins:shadow:1.2.1"
        classpath "commons-io:commons-io:2.4"
        classpath 'clojuresque:clojuresque:1.7.0'
    }
}

apply plugin: "io.ratpack.ratpack-groovy"
apply plugin: "com.github.johnrengelman.shadow"
apply plugin: "idea"
apply plugin: "eclipse"
apply plugin: "clojure"

repositories {
    jcenter()
    clojarsRepo()
}

dependencies {
    // SpringLoaded enables runtime hot reloading.
    // It is not part of the app runtime and is not shipped in the distribution.
    springloaded "org.springframework:springloaded:1.2.3.RELEASE"

    // Default SLF4J binding.  Note that this is a blocking implementation.
    // See here for a non blocking appender http://logging.apache.org/log4j/2.x/manual/async.html
    runtime 'org.slf4j:slf4j-simple:1.7.12'

    testCompile "org.spockframework:spock-core:1.0-groovy-2.4"
    testCompile "org.gebish:geb-spock:0.10.0"
    testCompile("com.github.detro.ghostdriver:phantomjsdriver:1.1.0") {
        transitive = false
    }
    testCompile "org.seleniumhq.selenium:selenium-support:2.43.1"
    testCompile "org.codehaus.groovy.modules.http-builder:http-builder:0.7.2"

    compile "org.clojure:clojure:1.6.0"
    compile "org.clojure:tools.nrepl:0.2.10"
}

sourceSets {
    integrationTest {
        compileClasspath = sourceSets.main.output + configurations.testRuntime
        runtimeClasspath = output + sourceSets.main.output + configurations.testRuntime
        groovy {
            srcDir 'src/integrationTest/groovy'
        }
    }
}

test {
    testLogging {
        events "failed"
        exceptionFormat "short"

        info.events = ["failed", "skipped"]
    }
}

task downloadPhantomJs {
    def osFilenamePart
    if(Os.isFamily(Os.FAMILY_WINDOWS)) {
        osFilenamePart = "windows.zip"
    } else if(Os.isFamily(Os.FAMILY_MAC)) {
        osFilenamePart = "macosx.zip"
    } else if(Os.isFamily(Os.FAMILY_UNIX)) {
        osFilenamePart = Os.isArch("amd64") ? "linux-x86_64.tar.bz2" : "linux-i686.tar.bz2"
    }

    def filename = "phantomjs-$phantomJsVersion-$osFilenamePart"
    def outputFile = file("$buildDir/webdriver/$filename")
    inputs.property("phantomJsVersion", phantomJsVersion)
    outputs.file(outputFile)

    doLast {
        FileUtils.copyURLToFile(new URL("https://bitbucket.org/ariya/phantomjs/downloads/$filename"), outputFile)
    }
}

task unzipPhantomJs(type: Copy) {
    def outputDir = file("$buildDir/webdriver/phantomjs")
    dependsOn downloadPhantomJs
    outputs.dir(outputDir)

    def archive = downloadPhantomJs.outputs.files.singleFile

    from(Os.isFamily(Os.FAMILY_MAC) || Os.isFamily(Os.FAMILY_WINDOWS) ? zipTree(archive) : tarTree(archive))
    into(outputDir)
    eachFile { FileCopyDetails fcp ->
        fcp.relativePath = new RelativePath(!fcp.directory, *fcp.relativePath.segments[1..-1])
    }
}

task integrationTest(type: Test) {
    dependsOn unzipPhantomJs

    group = 'verification'
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath

    def phantomJsFilename = Os.isFamily(Os.FAMILY_WINDOWS) ? "phantomjs.exe" : "bin/phantomjs"
    systemProperty "phantomjs.binary.path", new File(unzipPhantomJs.outputs.files.singleFile, phantomJsFilename).absolutePath

    systemProperty "geb.env", "phantomJs"
}

clojure {
    warnOnReflection = true
    aotCompile = false
}